<!DOCTYPE html>
<html lang="pl">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>üêù ATC Dashboard</title>
<script src="https://cdn.jsdelivr.net/npm/chart.js@4"></script>
<style>
  * { margin: 0; padding: 0; box-sizing: border-box; }
  body { background: #0a0a0f; color: #e0e0e0; font-family: 'Segoe UI', system-ui, sans-serif; padding: 12px; min-height: 100vh; }
  
  .header { display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px; flex-wrap: wrap; gap: 8px; }
  .header h1 { font-size: 1.4em; color: #ffd700; }
  .header .meta { font-size: 0.8em; color: #888; }
  .header .refresh { background: #222; border: 1px solid #444; color: #ccc; padding: 4px 12px; border-radius: 4px; cursor: pointer; font-size: 0.8em; }
  .header .refresh:hover { background: #333; }
  
  .cards { display: grid; grid-template-columns: repeat(auto-fit, minmax(140px, 1fr)); gap: 8px; margin-bottom: 16px; }
  .card { background: #14141f; border: 1px solid #222; border-radius: 8px; padding: 12px; text-align: center; }
  .card .label { font-size: 0.7em; color: #888; text-transform: uppercase; letter-spacing: 1px; }
  .card .value { font-size: 1.5em; font-weight: bold; margin-top: 4px; }
  .card .sub { font-size: 0.75em; color: #888; margin-top: 2px; }
  .green { color: #00e676; }
  .red { color: #ff5252; }
  .gold { color: #ffd700; }
  .blue { color: #448aff; }
  
  .grid2 { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; margin-bottom: 16px; }
  @media (max-width: 700px) { .grid2 { grid-template-columns: 1fr; } }
  
  .panel { background: #14141f; border: 1px solid #222; border-radius: 8px; padding: 12px; }
  .panel h3 { font-size: 0.9em; color: #ffd700; margin-bottom: 8px; border-bottom: 1px solid #222; padding-bottom: 4px; }
  
  .chart-container { position: relative; height: 200px; }
  
  table { width: 100%; border-collapse: collapse; font-size: 0.75em; }
  th { text-align: left; color: #888; font-weight: 500; padding: 4px 6px; border-bottom: 1px solid #222; }
  td { padding: 4px 6px; border-bottom: 1px solid #1a1a2e; }
  tr:hover td { background: #1a1a2e; }
  
  .pos-table { max-height: 500px; overflow-y: auto; }
  .countdown { font-size: 0.7em; padding: 2px 6px; border-radius: 3px; display: inline-block; }
  .countdown.soon { background: #ff525233; color: #ff8a80; }
  .countdown.today { background: #ffd70033; color: #ffd740; }
  .countdown.later { background: #448aff22; color: #82b1ff; }
  
  .loading { text-align: center; padding: 40px; color: #888; }
  
  .sortable { cursor: pointer; user-select: none; }
  .sortable:hover { color: #ffd700; }
  .sort-asc::after { content: ' ‚ñ≤'; color: #ffd700; }
  .sort-desc::after { content: ' ‚ñº'; color: #ffd700; }
  
  .filter-btn { background: #222; border: 1px solid #333; color: #888; padding: 4px 10px; border-radius: 4px; cursor: pointer; margin-right: 4px; font-size: 0.8em; }
  .filter-btn:hover { background: #333; color: #ccc; }
  .filter-btn.active { background: #ffd70033; border-color: #ffd700; color: #ffd700; }
  
  .status-tag { padding: 2px 6px; border-radius: 3px; font-size: 0.8em; font-weight: bold; }
  .status-winning { background: #00e67633; color: #69f0ae; }
  .status-losing { background: #ff525233; color: #ff8a80; }
  .status-pending { background: #ffd70033; color: #ffd740; }
  .status-resolved { background: #448aff22; color: #82b1ff; }
</style>
</head>
<body>

<div class="header">
  <h1>üêù ATC Dashboard</h1>
  <div class="meta" id="lastUpdate">Loading...</div>
  <button class="refresh" onclick="loadData()">üîÑ Refresh</button>
</div>

<div class="cards" id="cards"><div class="loading">Loading data from Polymarket...</div></div>

<div class="grid2">
  <div class="panel">
    <h3>ü•ß Category Allocation</h3>
    <div class="chart-container"><canvas id="categoryChart"></canvas></div>
  </div>
  <div class="panel">
    <h3>üìä Win/Loss</h3>
    <div class="chart-container"><canvas id="winLossChart"></canvas></div>
  </div>
</div>

<div class="panel" style="margin-bottom: 16px;">
  <h3>üí∞ Crypto Positions ‚Äî Live Prices</h3>
  <div id="cryptoPrices" style="display: flex; gap: 16px; flex-wrap: wrap; margin-bottom: 12px; font-size: 0.85em;">
    <span>Loading prices...</span>
  </div>
  <div class="pos-table" style="max-height: 300px;">
    <table id="cryptoTable">
      <thead>
        <tr>
          <th>Market</th>
          <th>Bet</th>
          <th>Asset @ Entry</th>
          <th>Asset Now</th>
          <th>Trend</th>
          <th>Bet Entry</th>
          <th>Bet Now</th>
          <th>Invested</th>
          <th>Value</th>
          <th>P/L</th>
        </tr>
      </thead>
      <tbody id="cryptoBody"></tbody>
    </table>
  </div>
  <div id="cryptoSummary" style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #333; font-size: 0.85em;"></div>
</div>

<div class="panel" style="margin-bottom: 16px;">
  <h3>üé∞ All Bets ‚Äî <span id="betsCount">0</span> total</h3>
  <div style="margin-bottom: 8px; font-size: 0.8em;">
    <button class="filter-btn active" data-filter="all">All</button>
    <button class="filter-btn" data-filter="winning">üü¢ Winning</button>
    <button class="filter-btn" data-filter="losing">üî¥ Losing</button>
    <button class="filter-btn" data-filter="pending">üü° Pending</button>
  </div>
  <div class="pos-table" style="max-height: 400px;">
    <table id="betsTable">
      <thead>
        <tr>
          <th class="sortable" data-sort="time">‚è∞ Time ‚Üï</th>
          <th class="sortable" data-sort="market">Market ‚Üï</th>
          <th>Bet @ Entry</th>
          <th class="sortable" data-sort="size">Shares ‚Üï</th>
          <th class="sortable" data-sort="now">Now ‚Üï</th>
          <th class="sortable" data-sort="invested">Cost ‚Üï</th>
          <th class="sortable" data-sort="value">Value ‚Üï</th>
          <th class="sortable" data-sort="pnl">P&L ‚Üï</th>
          <th>Status</th>
        </tr>
      </thead>
      <tbody id="betsBody"></tbody>
    </table>
  </div>
</div>

<div class="panel" style="margin-bottom: 16px;">
  <h3>üìä Active Positions ‚Äî sorted by resolution time</h3>
  <div class="pos-table">
    <table id="posTable">
      <thead>
        <tr>
          <th>‚è∞ Resolution</th>
          <th>Market</th>
          <th>Outcome</th>
          <th>Prob</th>
          <th>Value</th>
          <th>P&L</th>
        </tr>
      </thead>
      <tbody id="posBody"></tbody>
    </table>
  </div>
</div>

<script>
const WALLET = '0xEE477AE132dc9b21e8f6C976E24fe9Dd9b49AD74';
const TOTAL_DEPOSITED = 183.32;
const USDC_E = '0x2791Bca1f2de4661ED88A30C99A7a9449Aa84174';

// Estimated prices at purchase (Feb 4, 2026 evening ~20:00 UTC)
const ENTRY_PRICES = {
  BTC: 73500,  // ~$73-74K on Feb 4 evening
  ETH: 2650,   // ~$2,600-2,700 on Feb 4 evening
  SOL: 190,    // ~$180-200 on Feb 4 evening
  XRP: 2.40    // ~$2.30-2.50 on Feb 4 evening
};

async function getCryptoPrices() {
  try {
    const resp = await fetch('https://api.coingecko.com/api/v3/simple/price?ids=bitcoin,ethereum,solana,ripple&vs_currencies=usd&include_24hr_change=true');
    const data = await resp.json();
    return {
      BTC: { price: data.bitcoin.usd, change: data.bitcoin.usd_24h_change },
      ETH: { price: data.ethereum.usd, change: data.ethereum.usd_24h_change },
      SOL: { price: data.solana.usd, change: data.solana.usd_24h_change },
      XRP: { price: data.ripple.usd, change: data.ripple.usd_24h_change }
    };
  } catch (e) {
    return { BTC: { price: 0, change: 0 }, ETH: { price: 0, change: 0 }, SOL: { price: 0, change: 0 }, XRP: { price: 0, change: 0 } };
  }
}

function detectCryptoAsset(title) {
  const t = title.toLowerCase();
  if (t.includes('bitcoin') || t.includes('btc')) return 'BTC';
  if (t.includes('ethereum') || t.includes('eth')) return 'ETH';
  if (t.includes('solana') || t.includes('sol')) return 'SOL';
  if (t.includes('xrp')) return 'XRP';
  return null;
}

function detectDirection(title, outcome) {
  const t = title.toLowerCase();
  const o = outcome.toLowerCase();
  if (o === 'down' || o === 'no') return 'SHORT';
  if (o === 'up' || o === 'yes') return 'LONG';
  return o.toUpperCase();
}

let categoryChart, winLossChart;

function formatCountdown(endDate) {
  if (!endDate) return { text: '?', cls: 'later' };
  const now = Date.now();
  const end = new Date(endDate).getTime();
  const diff = end - now;
  
  if (diff <= 0) return { text: '‚è≥ RESOLVING', cls: 'soon' };
  
  const hours = diff / 3600000;
  if (hours < 1) return { text: `${Math.floor(diff/60000)}m`, cls: 'soon' };
  if (hours < 6) return { text: `${hours.toFixed(1)}h`, cls: 'soon' };
  if (hours < 24) return { text: `${hours.toFixed(0)}h`, cls: 'today' };
  const days = Math.floor(hours / 24);
  return { text: `${days}d ${Math.floor(hours%24)}h`, cls: 'later' };
}

function formatTime(endDate) {
  if (!endDate) return '';
  const d = new Date(endDate);
  return d.toLocaleString('pl-PL', { timeZone: 'Europe/Warsaw', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit' });
}

function pnlColor(v) { return v >= 0 ? 'green' : 'red'; }
function pnlSign(v) { return v >= 0 ? `+$${v.toFixed(2)}` : `-$${Math.abs(v).toFixed(2)}`; }

function formatTimeAgo(timestamp) {
  const now = Date.now();
  const diff = now - timestamp;
  const minutes = Math.floor(diff / 60000);
  const hours = Math.floor(diff / 3600000);
  const days = Math.floor(diff / 86400000);
  
  if (minutes < 1) return 'just now';
  if (minutes < 60) return `${minutes}m ago`;
  if (hours < 24) return `${hours}h ago`;
  if (days < 7) return `${days}d ago`;
  return new Date(timestamp).toLocaleDateString('pl-PL');
}

async function getUSDCBalance() {
  try {
    const resp = await fetch('https://polygon-bor-rpc.publicnode.com', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        jsonrpc: '2.0',
        method: 'eth_call',
        params: [{
          to: USDC_E,
          data: '0x70a08231000000000000000000000000' + WALLET.slice(2).toLowerCase()
        }, 'latest'],
        id: 1
      })
    });
    const { result } = await resp.json();
    return parseInt(result, 16) / 1e6;
  } catch (e) {
    return 0;
  }
}

async function renderCryptoSection(positions) {
  const prices = await getCryptoPrices();
  
  // Render price bar
  const priceBar = document.getElementById('cryptoPrices');
  priceBar.innerHTML = Object.entries(prices).map(([sym, data]) => {
    const entryP = ENTRY_PRICES[sym];
    const curP = data.price;
    const pctFromEntry = ((curP - entryP) / entryP * 100).toFixed(1);
    const trendColor = curP < entryP ? '#ff5252' : '#00e676';
    const trendIcon = curP < entryP ? 'üìâ' : 'üìà';
    return `<span style="background:#1a1a2e; padding:6px 12px; border-radius:6px;">
      <b style="color:${sym === 'BTC' ? '#f7931a' : sym === 'ETH' ? '#627eea' : sym === 'SOL' ? '#9945ff' : '#00aae4'}">${sym}</b>
      $${curP.toLocaleString()} 
      <span style="color:${trendColor}; font-size:0.85em;">${trendIcon} ${pctFromEntry}% vs entry</span>
    </span>`;
  }).join('');
  
  // Filter crypto positions
  const cryptoPos = positions.filter(p => detectCryptoAsset(p.title));
  
  // Render crypto table
  const tbody = document.getElementById('cryptoBody');
  let totalInvested = 0, totalValue = 0, totalPnl = 0;
  
  tbody.innerHTML = cryptoPos.map(p => {
    const asset = detectCryptoAsset(p.title);
    const outcome = p.outcome || '';
    const entryAssetPrice = ENTRY_PRICES[asset];
    const curAssetPrice = prices[asset]?.price || 0;
    const assetTrend = curAssetPrice < entryAssetPrice ? 'üìâ' : 'üìà';
    const assetTrendPct = ((curAssetPrice - entryAssetPrice) / entryAssetPrice * 100).toFixed(1);
    
    const betEntry = parseFloat(p.avgPrice || 0);
    const betNow = parseFloat(p.curPrice || 0);
    const invested = parseFloat(p.initialValue || 0);
    const value = parseFloat(p.currentValue || 0);
    const pnl = parseFloat(p.cashPnl || 0);
    
    totalInvested += invested;
    totalValue += value;
    totalPnl += pnl;
    
    // Outcome styling - show actual bet direction with emoji
    const outcomeLC = outcome.toLowerCase();
    let betDisplay, betColor, betEmoji;
    if (outcomeLC === 'up' || outcomeLC === 'yes') {
      betDisplay = outcome.toUpperCase();
      betColor = '#69f0ae';
      betEmoji = 'üìà';
    } else if (outcomeLC === 'down' || outcomeLC === 'no') {
      betDisplay = outcome.toUpperCase();
      betColor = '#ff8a80';
      betEmoji = 'üìâ';
    } else {
      betDisplay = outcome;
      betColor = '#888';
      betEmoji = '';
    }
    
    const pnlColor = pnl >= 0 ? '#00e676' : '#ff5252';
    const assetColor = asset === 'BTC' ? '#f7931a' : asset === 'ETH' ? '#627eea' : asset === 'SOL' ? '#9945ff' : '#00aae4';
    
    // Short title
    let shortTitle = p.title.replace(/Bitcoin|Ethereum|Solana/gi, '').replace(/Up or Down/gi, 'U/D').trim();
    if (shortTitle.length > 30) shortTitle = shortTitle.slice(0, 30) + '...';
    
    return `<tr>
      <td style="max-width:180px; font-size:0.85em;">${shortTitle}</td>
      <td><span style="color:${betColor}; font-weight:bold;">${betEmoji} ${betDisplay}</span></td>
      <td style="color:${assetColor};">$${entryAssetPrice.toLocaleString()}</td>
      <td style="color:${assetColor};">$${curAssetPrice.toLocaleString()}</td>
      <td>${assetTrend} <span style="color:${curAssetPrice < entryAssetPrice ? '#ff5252' : '#00e676'}">${assetTrendPct}%</span></td>
      <td>$${betEntry.toFixed(2)}</td>
      <td>$${betNow.toFixed(2)}</td>
      <td>$${invested.toFixed(2)}</td>
      <td>$${value.toFixed(2)}</td>
      <td style="color:${pnlColor}; font-weight:bold;">${pnl >= 0 ? '+' : ''}$${pnl.toFixed(2)}</td>
    </tr>`;
  }).join('');
  
  // Summary
  const summaryDiv = document.getElementById('cryptoSummary');
  const pnlPct = totalInvested > 0 ? (totalPnl / totalInvested * 100).toFixed(1) : 0;
  summaryDiv.innerHTML = `
    <b>CRYPTO TOTAL:</b> 
    Invested: <span class="gold">$${totalInvested.toFixed(2)}</span> | 
    Value: <span class="blue">$${totalValue.toFixed(2)}</span> | 
    P/L: <span class="${totalPnl >= 0 ? 'green' : 'red'}" style="font-weight:bold;">${totalPnl >= 0 ? '+' : ''}$${totalPnl.toFixed(2)} (${pnlPct}%)</span>
  `;
}

async function loadData() {
  try {
    document.getElementById('cards').innerHTML = '<div class="loading">Loading...</div>';
    
    const [posResp, cash] = await Promise.all([
      fetch(`https://data-api.polymarket.com/positions?user=${WALLET}&sizeThreshold=0`),
      getUSDCBalance()
    ]);
    
    const positions = await posResp.json();
    
    // Calculate stats
    let totalVal = 0, totalCost = 0, winners = 0, losers = 0;
    const categories = {};
    
    for (const p of positions) {
      const val = parseFloat(p.currentValue || 0);
      const cost = parseFloat(p.initialValue || 0);
      const pnl = parseFloat(p.cashPnl || 0);
      
      totalVal += val;
      totalCost += cost;
      if (pnl > 0.01) winners++;
      else if (pnl < -0.01) losers++;
      
      // Categorize
      const t = (p.title || '').toLowerCase();
      let cat = 'Other';
      if (t.includes('bitcoin') || t.includes('btc')) cat = 'BTC';
      else if (t.includes('ethereum') || t.includes('eth')) cat = 'ETH';
      else if (t.includes('xrp')) cat = 'XRP';
      else if (t.includes('solana') || t.includes('sol')) cat = 'SOL';
      else if (t.includes('dota') || t.includes('counter-strike') || t.includes('league')) cat = 'Esport';
      else if (t.match(/vs\.|thunder|spread|nuggets|timber|wild|pelicans|kings|cavaliers|raptors/)) cat = 'Sport';
      else if (t.match(/temperature|weather/)) cat = 'Weather';
      else if (t.match(/bank of|ecb|bartlett|democratic|republican/)) cat = 'Politics';
      
      if (!categories[cat]) categories[cat] = { value: 0, count: 0 };
      categories[cat].value += val;
      categories[cat].count++;
    }
    
    const portfolioValue = totalVal + cash;
    const realPnl = portfolioValue - TOTAL_DEPOSITED;
    const pnlPct = (realPnl / TOTAL_DEPOSITED * 100).toFixed(1);
    
    // Render cards
    document.getElementById('cards').innerHTML = `
      <div class="card">
        <div class="label">Portfolio</div>
        <div class="value gold">$${portfolioValue.toFixed(2)}</div>
        <div class="sub">deposited: $${TOTAL_DEPOSITED}</div>
      </div>
      <div class="card">
        <div class="label">Cash</div>
        <div class="value blue">$${cash.toFixed(2)}</div>
        <div class="sub">USDC.e</div>
      </div>
      <div class="card">
        <div class="label">Total P&L</div>
        <div class="value ${pnlColor(realPnl)}">${pnlSign(realPnl)}</div>
        <div class="sub">${pnlPct}%</div>
      </div>
      <div class="card">
        <div class="label">Positions</div>
        <div class="value">${positions.length}</div>
        <div class="sub">üü¢${winners} üî¥${losers}</div>
      </div>
      <div class="card">
        <div class="label">Position Value</div>
        <div class="value">$${totalVal.toFixed(2)}</div>
        <div class="sub">cost: $${totalCost.toFixed(2)}</div>
      </div>
    `;
    
    // Render positions table
    const sorted = [...positions].sort((a, b) => {
      if (!a.endDate) return 1;
      if (!b.endDate) return -1;
      return new Date(a.endDate) - new Date(b.endDate);
    });
    
    const tbody = document.getElementById('posBody');
    tbody.innerHTML = sorted.map(p => {
      const cd = formatCountdown(p.endDate);
      const time = formatTime(p.endDate);
      const val = parseFloat(p.currentValue || 0);
      const pnl = parseFloat(p.cashPnl || 0);
      const prob = parseFloat(p.curPrice || 0);
      const probPct = (prob * 100).toFixed(0);
      const probColor = prob > 0.7 ? '#00e676' : prob > 0.4 ? '#ffd740' : '#ff5252';
      
      return `<tr>
        <td>
          <span class="countdown ${cd.cls}">${cd.text}</span>
          <span style="color:#666; font-size:0.85em; margin-left:4px;">${time}</span>
        </td>
        <td style="max-width:250px; overflow:hidden; text-overflow:ellipsis;">${(p.title||'').slice(0,60)}</td>
        <td><b>${p.outcome || ''}</b></td>
        <td>${probPct}%</td>
        <td>$${val.toFixed(2)}</td>
        <td class="${pnlColor(pnl)}">${pnlSign(pnl)}</td>
      </tr>`;
    }).join('');
    
    // Render crypto section
    await renderCryptoSection(positions);
    
    // Render charts
    renderCategoryChart(categories);
    renderWinLossChart(winners, losers, positions.length - winners - losers);
    
    document.getElementById('lastUpdate').textContent = 
      `Updated: ${new Date().toLocaleTimeString('pl-PL', { timeZone: 'Europe/Warsaw' })}`;
      
  } catch (e) {
    document.getElementById('cards').innerHTML = `<div class="loading" style="color:#ff5252;">Error: ${e.message}</div>`;
  }
}

function renderCategoryChart(cats) {
  const labels = Object.keys(cats);
  const values = labels.map(k => cats[k].value);
  const colors = { BTC: '#f7931a', ETH: '#627eea', XRP: '#00aae4', SOL: '#9945ff', Sport: '#ff6b35', Esport: '#e040fb', Weather: '#4fc3f7', Politics: '#ab47bc', Other: '#888' };
  
  const ctx = document.getElementById('categoryChart').getContext('2d');
  if (categoryChart) categoryChart.destroy();
  
  categoryChart = new Chart(ctx, {
    type: 'doughnut',
    data: {
      labels,
      datasets: [{ data: values, backgroundColor: labels.map(l => colors[l] || '#888'), borderWidth: 0 }]
    },
    options: {
      responsive: true, maintainAspectRatio: false,
      plugins: {
        legend: { position: 'right', labels: { color: '#ccc', font: { size: 10 }, padding: 6 } }
      }
    }
  });
}

function renderWinLossChart(wins, losses, neutral) {
  const ctx = document.getElementById('winLossChart').getContext('2d');
  if (winLossChart) winLossChart.destroy();
  
  winLossChart = new Chart(ctx, {
    type: 'doughnut',
    data: {
      labels: ['Winning', 'Losing', 'Neutral'],
      datasets: [{ data: [wins, losses, neutral], backgroundColor: ['#00e676', '#ff5252', '#888'], borderWidth: 0 }]
    },
    options: {
      responsive: true, maintainAspectRatio: false,
      plugins: {
        legend: { position: 'right', labels: { color: '#ccc', font: { size: 10 }, padding: 6 } }
      }
    }
  });
}

// === BETS TABLE WITH SORTING ===
let allBets = [];
let currentSort = { col: 'time', dir: 'desc' };
let currentFilter = 'all';

async function fetchActivity() {
  try {
    const resp = await fetch(`https://data-api.polymarket.com/activity?user=${WALLET}&limit=200`);
    return await resp.json();
  } catch (e) {
    return [];
  }
}

async function renderBetsTable(positions) {
  // Fetch real activity data with timestamps
  const activity = await fetchActivity();
  
  // Group activity by conditionId to get entry times
  const entryTimes = {};
  const trades = activity.filter(a => a.type === 'TRADE');
  
  for (const trade of trades) {
    const key = trade.conditionId + '_' + trade.outcome;
    if (!entryTimes[key] || trade.timestamp < entryTimes[key].timestamp) {
      entryTimes[key] = trade;
    }
  }
  
  allBets = activity.filter(a => a.type === 'TRADE').map(a => {
    const timestamp = a.timestamp * 1000; // Convert to ms
    const entry = parseFloat(a.price || 0);
    const size = parseFloat(a.size || 0);
    const cost = parseFloat(a.usdcSize || 0);
    
    // Find current position data
    const pos = positions.find(p => p.conditionId === a.conditionId && p.outcome === a.outcome);
    const now = pos ? parseFloat(pos.curPrice || 0) : entry;
    const value = pos ? size * now : cost;
    const pnl = value - cost;
    
    // Status based on current price
    let status = 'pending';
    if (now >= 0.95) status = 'winning';
    else if (now <= 0.05) status = 'losing';
    else if (now > entry * 1.1) status = 'winning';
    else if (now < entry * 0.9) status = 'losing';
    
    return {
      timestamp,
      entryTime: new Date(timestamp),
      market: (a.title || '').slice(0, 50),
      title: a.title,
      outcome: a.outcome || '',
      side: a.side,
      entry,
      now,
      size,
      invested: cost,
      value,
      pnl,
      status,
      txHash: a.transactionHash
    };
  });
  
  document.getElementById('betsCount').textContent = allBets.length;
  applyFilterAndSort();
}

function applyFilterAndSort() {
  let filtered = allBets;
  
  // Apply filter
  if (currentFilter !== 'all') {
    filtered = allBets.filter(b => b.status === currentFilter);
  }
  
  // Apply sort
  filtered.sort((a, b) => {
    let va, vb;
    switch (currentSort.col) {
      case 'time': va = a.timestamp || 0; vb = b.timestamp || 0; break;
      case 'market': va = a.market.toLowerCase(); vb = b.market.toLowerCase(); break;
      case 'entry': va = a.entry; vb = b.entry; break;
      case 'size': va = a.size; vb = b.size; break;
      case 'now': va = a.now; vb = b.now; break;
      case 'invested': va = a.invested; vb = b.invested; break;
      case 'value': va = a.value; vb = b.value; break;
      case 'pnl': va = a.pnl; vb = b.pnl; break;
      default: va = 0; vb = 0;
    }
    if (typeof va === 'string') {
      return currentSort.dir === 'asc' ? va.localeCompare(vb) : vb.localeCompare(va);
    }
    return currentSort.dir === 'asc' ? va - vb : vb - va;
  });
  
  // Render
  const tbody = document.getElementById('betsBody');
  tbody.innerHTML = filtered.map(b => {
    // Format time as "X ago" like Polymarket
    const timeAgo = formatTimeAgo(b.timestamp);
    const exactTime = b.entryTime ? b.entryTime.toLocaleString('pl-PL', { 
      timeZone: 'Europe/Warsaw', month: '2-digit', day: '2-digit', hour: '2-digit', minute: '2-digit' 
    }) : '';
    
    const outcomeColor = b.outcome.toLowerCase() === 'up' || b.outcome.toLowerCase() === 'yes' ? '#69f0ae' : 
                         b.outcome.toLowerCase() === 'down' || b.outcome.toLowerCase() === 'no' ? '#ff8a80' : '#888';
    const outcomeEmoji = b.outcome.toLowerCase() === 'up' || b.outcome.toLowerCase() === 'yes' ? 'üìà' : 
                         b.outcome.toLowerCase() === 'down' || b.outcome.toLowerCase() === 'no' ? 'üìâ' : '';
    
    const statusClass = `status-${b.status}`;
    const statusText = b.status === 'winning' ? 'üü¢ WIN' : b.status === 'losing' ? 'üî¥ LOSS' : 'üü° PEND';
    
    const pnlColor = b.pnl >= 0 ? '#00e676' : '#ff5252';
    
    return `<tr>
      <td style="font-size:0.85em;" title="${exactTime}"><span style="color:#ffd700;">${timeAgo}</span></td>
      <td style="max-width:200px; overflow:hidden; text-overflow:ellipsis;" title="${b.title}">${b.market}</td>
      <td style="color:${outcomeColor}; font-weight:bold;">${outcomeEmoji} ${b.outcome} <span style="color:#888; font-weight:normal;">${(b.entry * 100).toFixed(0)}¬¢</span></td>
      <td style="color:#888;">${b.size.toFixed(1)}</td>
      <td>${(b.now * 100).toFixed(0)}¬¢</td>
      <td>$${b.invested.toFixed(2)}</td>
      <td>$${b.value.toFixed(2)}</td>
      <td style="color:${pnlColor}; font-weight:bold;">${b.pnl >= 0 ? '+' : ''}$${b.pnl.toFixed(2)}</td>
      <td><span class="status-tag ${statusClass}">${statusText}</span></td>
    </tr>`;
  }).join('');
  
  // Update sort indicators
  document.querySelectorAll('#betsTable .sortable').forEach(th => {
    th.classList.remove('sort-asc', 'sort-desc');
    if (th.dataset.sort === currentSort.col) {
      th.classList.add(currentSort.dir === 'asc' ? 'sort-asc' : 'sort-desc');
    }
  });
}

// Sort click handlers
document.querySelectorAll('#betsTable .sortable').forEach(th => {
  th.addEventListener('click', () => {
    const col = th.dataset.sort;
    if (currentSort.col === col) {
      currentSort.dir = currentSort.dir === 'asc' ? 'desc' : 'asc';
    } else {
      currentSort.col = col;
      currentSort.dir = 'desc';
    }
    applyFilterAndSort();
  });
});

// Filter click handlers  
document.querySelectorAll('.filter-btn').forEach(btn => {
  btn.addEventListener('click', () => {
    document.querySelectorAll('.filter-btn').forEach(b => b.classList.remove('active'));
    btn.classList.add('active');
    currentFilter = btn.dataset.filter;
    applyFilterAndSort();
  });
});

// Patch loadData to also render bets table
const originalLoadData = loadData;
loadData = async function() {
  await originalLoadData();
  // Fetch positions again for bets table (or reuse)
  try {
    const resp = await fetch(`https://data-api.polymarket.com/positions?user=${WALLET}&sizeThreshold=0`);
    const positions = await resp.json();
    renderBetsTable(positions);
  } catch (e) {}
};

// Load on start and auto-refresh
loadData();
setInterval(loadData, 60000);
</script>
</body>
</html>
